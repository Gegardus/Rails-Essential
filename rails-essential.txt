DATABASES AND MIGRATIONS

Use the command line to generate migrations

In this movie, we're going to learn how to generate migrations. We can generate a migration from the command line using the command rails generate migration, followed by the name of the migration in camel case. This is similar to the command we used to generate a controller earlier. It will create a migration file in the db directory of our project, then we just add our database changes to it. The migration code is a Ruby class with two methods, up and down. Up contains the changes we want to make to the current database. The down method contains changes to undo the code in the up method. So if up creates a new table, then we would expect down to drop that table. This enables us to both make changes and to reverse them. Because Rails is smart and it knows that the opposite of create table is drop table, it can often infer the opposite of the changes that we want. So we can use the change method as a shorthand. The change method contains the same code as the up method would, and Rails will do the opposite when it's migrating down. 

Run migrations to change the database schema

In this movie, we will learn how to run migrations to change our database. From the command line and the root of our project, we can run our migrations with rails db:migrate. Rails will execute the code in the up or change method for any migrations that have not been executed before. Let's try it. We already wrote two migrations. We have DoNothingYet and we have CreateTasks, but we haven't executed any of that code yet. Go to the root of the rails application and type rails db:migrate. When we hit return, it tells you what it did. It tells you the migration, migrating, migrated, migrating, create_table, and migrated. Then gives you some stats as well. To see the results of this, let's actually go into MySQL directly. I'll do that with -u rails user and -p, to put in my password, task manager development, and then I'll type in my password. Oops, I typed it wrong. Let's try that one more time. There we go. Now let's do SHOW TABLES; and you can see that it did add my task table. SHOW FIELDS FROM tasks; and we get a list. Let's make this a little bigger so we can see it. Gives you a nice look at what the table looks like. Notice that it did add an id column that was created automatically, and it set it as the primary key, and made it auto_increment. You can see each of the columns in our migration were also added, and they gave it the correct SQL column type. Now if we go back and we do SHOW TABLES; again, you'll see that it created two other tables as well. Schema_migrations is the one I want us to look at. Let's do SELECT * FROM schema_migrations, and you can see that it added two timestamps there. And those two timestamps correspond to the timestamps at the beginning of the file name for each of these migrations. That's how rails knows which migrations have been run and which ones have not. Every time it runs the migration successfully, it adds its timestamp to the schema_migrations table. If we migrate back down and reverse some of those migrations, then it will remove those entries from the schema_migrations table. Other useful migration commands are rails db:migrate:status, which will display which migrations have run and not been run. rails db:migrate with VERSION=0 in all capitals after it. This will undo all migrations. It will essentially go back to the beginning. For example, any tables that were created will be dropped. And then we can have rails db:migrate and VERSION, but this time we're going to specify the timestamp for a particular migration. It will migrate up or down until it gets to that specific version and then stop. Let's try them. I'll exit out of MySQL, so I'm back to my project command line. And, from here, let's run rails db:migrate:status. It'll come back and tell us the status of them. It says that they are both up. It'll say down if one hasn't been run. It gives us the Migration ID. We can do rails db:migrate and then VERSION=0. Now it will run the down methods in each of those, right. So now it goes in reverse order, starting with the newest migration first. It drops the table tasks and then it does our DoNothingYet migration. Now if we hit the up arrow so that we get status again, we can see that now they're both listed as being down. And if we want to pick a particular version, we can change VERSION to be something. This is very handy to just paste it in. Let's say we just want to run this first migration. I'll paste that in, I'll hit return, It'll run just the DoNothingYet migration. Run status you'll see now that one is up, but the other one is down. And if I finally run rake db:migrate, it'll now run just the second migration because it knows the first migration has already been run. You can play around with running these migration versions on your own. When you're done experimenting, make sure that you fully migrate so that all the migrations have been run before you continue with the tutorial.

MODELS AND ACTIVE RECORD

ActiveRecord and ActiveRelation

In this chapter, we will learn to use models. And we'll start by learning about ActiveRecord and ActiveRelation. In the MVC diagram, models bridge the gap between the controller and the database. And they do that using these two parts of Ruby on Rails. ActiveRecord is a common design pattern for working with relational databases. ActiveRecord allows us to retrieve and manipulate data from the database as objects, not as static rows. ActiveRecord also makes our Ruby objects intelligent. Our objects understand the structure of the database tables, and they know how to interact with them. They contain not only data, but they also know how to create, read, update, and delete rows in those database tables. They can contain complex functionality, like data validation and error handling. And ActiveRecord objects can be manipulated and then saved to the database with just a few simple commands. Let me demonstrate. This code is interacting with a user class. It first sets a variable to a new instance of the user class, and then it sets the attribute for first_name. Then it calls the save method on the object. That simple save command causes ActiveRecord to construct the appropriate SQL INSERT statement to add a row to the user's table. This is much easier than writing raw SQL, especially in cases where the INSERT is long and complex. In the next section, it sets the attribute for last_name and calls the save method again. Not only does ActiveRecord construct the SQL for us, it knows that this object has been saved previously. So it creates an SQL update statement this time. In the last line, it calls the destroy method, and ActiveRecord will write an SQL DELETE statement to delete a row from the table. This is easy to use and easy to understand. The built-in code does the heavy lifting for us. ActiveRelation, also sometimes called Arel for short, works with ActiveRecord. ActiveRelation is an object-oriented interpretation of relational algebra, which is a fancy way of saying it simplifies the creation of complex database queries. In practice, several small queries can be added together in a chain, and ActiveRelation will combine them. It will use efficient SQL with complex joins and aggregations, and the queries won't execute until they're needed, mostly to allow chaining on more queries if you want them. In this example, the variable users is being set to a query on the User model. Then in the next line, it adds on an order and limit clause, but it doesn't query the database yet. We could chain on more queries. If we get to a point where the code loops through the users in the set, then it would need to retrieve those records. So it combines the smaller queries into SQL and sends it to the database. ActiveRecord and ActiveRelation are powerful tools for working with databases inside your Ruby on Rails projects.

Use the Rails console to interact with a Rails project

The Rails Console provides access to a Ruby on Rails project from the command line. Throughout this chapter, we will use it to experiment with the models in isolation without having to worry about the controllers or the views yet. We can launch the Rails Console from the command line from the root of our project, with rails console dash E development. The dash E indicates that the next argument is the environment to use. Usually that will be development, but you can use the console with the production and test environments too. You can also abbreviate console as the letter C. Keep in mind that the Rails Console is interacting with the same project database as the web browser. Changes made here will affect what you see there. It's important that you remember this, especially if you're using the Rails Console on a production server. You may change live data that the public is using. If for example, you use the Rails Console and delete a customer record, that customer record is gone. Let's get a feel for the Rails Console. From the command line and the root of my Rails project, I'll type rails console dash E development. After a moment, it'll boot up the console and tell me that I'm in the development environment. The Rails Console is the interactive Ruby Console, called IRB, but with the addition of our Rails project loaded in, so that we can access our models and other code. We can execute Ruby code immediately like a calculator. One plus one or X equals hello, x.upcase.reverse. Notice that it offered me some suggestions as I was typing. We'll talk about how to turn that feature on or off in a moment. In the last chapter, we generated a model for task, and we can assign task equals capital task.new. And if we type task, then you can see the attributes of this object, which correspond to the columns in the task table. I can have task.name equals fold laundry, and I can call task.name and it will return that value back to me. This data is in memory. It's not saved to the database. We'll learn to save it in the next movie. But if we exit without calling any methods that make database changes, then we will not have affected what a browser might see in any way. If you make changes to your project code while the Rails Console is running and you want to use those changes, you will either need to exit and restart the console or you can also type reload with an exclamation point at the end. And the console will reload the project code. When we're done with the Rails Console, type exit to return to the regular command line. If you are like me and you don't like that auto complete feature, you can turn it off by running this command from the command line. This line will add a line to an IRB configuration file. Now, if I type rails C dash E development, it'll launch the console, but it won't have that auto complete. And we can see that by just trying the upcase method. And you'll see that it no longer offered me that auto complete feature. Spend some time getting familiar with it. We will use the Rails Console throughout this chapter.

Create records using ActiveRecord

In this movie, I will show you two techniques to create new records in the database table using models. I refer to the first technique as New + Save. It's a three step process. First, we instantiate an object. Instantiate means to create a new object of a class. The object it creates is called an instance of the class. Next, we set values on that instance. The final step is to save the object's data to the database table. The second technique has the same effect as New + Save, but it creates the record all in one step with a single command. Create will instantiate the object, set the values, and save it. Our models can do this type of work because they inherit from ActiveRecord. Well, actually they inherit from ApplicationRecord, which is another model that you see here, and that inherits from ActiveRecord::Base. ApplicationRecord is just a place to put code that's common to all of your models so you don't repeat yourself. Let's go into the Rails Console and try out the two techniques for saving records. rails console -e development. The first step is to instantiate an object, so I'll create a variable task, and I'll use the capital letter T to represent my model. Those are always going to be capitalized when we're referring to the class name. Then I'll use .new, and then in parenthesis, I'll put a hash that just has name, Fold the laundry and a comma, followed by position: 1. It created a new instance of the class, set the attribute for name and position, and assigned it to a variable so we can continue to work with it. Step two is to set values on the instance. We added some values already, but we can add more. Let's add task.description = 'Fold the laundry in the basket and put it in drawers'. There we go. And let's do task.completed = false. Now if I just type task, we can see that values have been set for those attributes. I will not set values for id, created_at, or updated_at. We're going to let Rails take care of those. If I type task.new_record with a question mark after it, this is another behavior of ActiveRecord. It keeps track of whether the data in this object has been saved to the database or not. When we ask for a new record, it'll tell us whether it's been saved or not. Step three is to save the instance, so we'll do that with task.save. It saved a new_record to the task table. It output the SQL statement that it used. Notice that it also returned either true or false, which will allow code to perform one action if the save succeeds or another action if the save fails. I'll hit the up arrow a couple of times, and we'll ask again whether it's a new record, and now the answer is false. Let's type task and look at the attributes again. You'll see that Rails automatically populated the columns for id, created_at, and updated_at for us. Now let's try the second technique using create. I'm just going to clear my screen, and let's do task2 = capital Task again to refer to the class, the model, and I'll use create as the method name, and then in parenthesis, I'll put the name: Sweep the porch, we'll make it position: 2, and completed: false. This time, it immediately added the record to the table. It also did not return true or false. It returned the object that it created, and that's useful because we assigned it to task2. So now I can say task2.new_record? It's not a new record, and if I check it out you can see that id, created_at, and update were also added. We now know two ways to create new records in the database. We created them from the Rails Console, but you can use these same techniques inside your controllers.

Delete records using ActiveRecord

In this movie, we will learn how to delete records in the database using active record. Deleting records is a two-step process, find plus destroy. First, you find the record and get back an instance of the class just like we did with update. Then, tell that instance that it should destroy itself. There's only one quirk that you need to remember. The method is called destroy even though it will send the database an SQL delete statement. There's another method called delete, but it doesn't work exactly the same, so use destroy. Let's try it. Launch the rails console unless you already have it open. Let's create a new task that we can then destroy. I'll just call task.create and I'll give this a name of bad task. I didn't even bother catching that in a variable. It just went and created it in the database. Notice it's ID here. It's three. We're going to need that. Alright, so the first step is to find the records in the database. Let me just clear my screen. Let's do that with task=task.find and the ID is three. Now that we've found that object, let's destroy it. We'll do that with task.destroy. Again, that's destroy and not delete. It sends an SQL delete statement and the record is gone. However, notice that the object is still around. I can type task. I can type task.name, but I can't change any of the values. task.name=test. I get back something called a frozen error that says can't modify frozen attributes. The attributes are frozen when an object is destroyed, but it can be useful to have the object still available to us. For example, we might want to show the user a message that says the task named bad task was just deleted successfully. But it really is gone from the database. If we call task.find ID three, you'll see that we get back an error, active record, record not found. It is easy to delete records as long as you remember to use the destroy method for it. You can do it from the Rails console or inside your controller code.

Define one-to-many associations between models

We've been using ActiveRecord to work with a single model in its database table. Ruby on Rails also makes it easy to work with the associations between relational database tables. Relational database associations usually come in three main types. We can have a one-to-one relationship between two tables, a one-to-many relationship or a many-to-many relationship. By far and away, one-to-many is the most common type. Let's look at an example. Let's imagine that I have a teacher who teaches several courses. We can say that the teacher has many courses. And each of those courses belongs to a teacher exclusively. In that case, we would store a foreign key on the courses table. And that foreign key would keep track of the teacher's ID so that we would know which course belongs to the teacher. And we could search for that ID either in the teachers table or the courses table to find the appropriate records. That's the general idea. In our application, we have a model called task already. We don't have another one to work with, but we can create one. We'll call it category. So let's say that each of our tasks can belong to one and only one category. So a category has many tasks, and a task belongs to a category. It's a one-to-many relationship. Before we can work with associations in Rails, we need to first create the relationship in the database, define the foreign keys between the tables. After that, we can define the relationship in the models so that Rails will know about that relationship. And we need to do that on both sides in both of the models. And then after that, we're able to use that relationship. Let's try it. We won't go into the Rails console just yet. Let's use the generator to generate a model migration for category, 'cause we don't have that yet. And it's going to have an attribute of name, which will be a string. And that's it. It's just going to be a very simple model with one column. So it created that for us. And if we open up our project, you can see that it added category over here for us. Now let's use Rails generate again. And we're going to, this time, create a migration, because we need to add the foreign key to the tasks table. 

So AddCategoryIdToTasks. So that'll create a migration for us. If we come here and look, we have the migration. And it's ready for us to populate. And we're going to do that with add column. And we're going to add a column to the tasks table. And the column will be called category ID. It will be an integer column. And because it's going to be a foreign key, we're also going to add an index to it so that we can look up values quickly on it. So that's it. That'll be part of the change method. So that means that the up will add the column, and the down would remove the column. Let's save it. Now, when we come back over here, we'll run rails db migrate to make those database changes. It added both the categories table and added that foreign key for us. Now we have our database in order. 

The second step is to come back over here to our models and tell Rails about that relationship. A task belongs to a category. And there's one other thing we should add here. If it is always definitely going to have a category, it's fine. But if we want to make it optional, we want to say optional true at the end. That's very important. Otherwise, we'll get an error, if there's not a category attached to a task. This gives us a little more flexibility. So a task belongs to a category. The relationship is optional. And category then has many tasks. 

Notice how I pluralize those. When it had many, I used the plural for tasks. And when I had task, and it belongs to one, I used the singular. That's it. Save both of those files. And now Rails knows about the association. And it'll look for the appropriate columns in order to connect them. Let's go into our console. And from the Rails console, let me just clear the screen, let's call category. We need to create a category. So let's have a category, category create. And let's give it a name. We'll just make it Weekly. All right. We now have a category, category dot tasks. We'll tell us what task belong to that category. Right now, there is nothing. So let's find a task. Task one equals task dot find one. And I'm just going to do task two equals task dot find two. So now I have two tasks assigned to variables. So now let's add category tasks. And I'm going to use the append operator, the two less than signs, to append task one onto its list of tasks. And it did. You can see that it updated it. And you can see that it changed its category ID to be one so that it matches. All right. Let's do the same thing, but this time, let's add task two onto it. It did the same thing. Now, if we say category dot tasks, there are two tasks there. And I can actually do count in order to see it comes back and tells me that there's two. If I want to delete one, I can use delete. Now, this is a little different. Before, it was destroy. We were getting rid of the records. This is delete to get rid of the relationship. Task two, let's take task two out of there. Now when I do task count, I get back one. I can also ask for empty, question mark, just like we can on an array to find out if it's empty. There is still one there. And if I wanted to get the first one out of it, category task first. We'll return that first object to us. Now, this is working from category looking at tasks. We can also go the other way around. Task one has a category. We can get back that object, or we can just keep working with it. We can say task one dot category dot name. It'll output the name of the tasks category. The associations built into Ruby on Rails contain a lot of rich features. This is just an introduction to get you started.

CRUD, REST AND RESOURCEFUL ROUTES

Learn about CRUD (create, read, update, delete)

In this chapter, we will learn to use resourceful routes in our projects. It can be challenging at first, but it's worth learning it, even as a beginner because it is a Rails default and most professional developers use it. We will also see that Ruby on Rails has helper methods that make it easier. We're going to start by talking about CRUD. CRUD is an acronym for create, read, update and delete. These are the primary operations we perform on data in the database. We create new records. We read records from the database. We update those records or we delete them. Our web application will perform the same four actions. Using standard CRUD actions organizes project code and helps to manage complexity as a project grows. Each of the four elements of CRUD can be divided into two actions. For create, we have new and create. New would display a form for a new record. The user would enter information into the form and then submit it to the create action. The create action would process that form data and try to add it to the database. If there's a problem, it can re-display the form so the user can fix it and submit it again. They work as a pair, a form and an action to process the form. Edit/update and delete/destroy work the same way. The two read actions are different. Index displays a list of records. Shows provides a detailed view of a single record. The right column has examples of URLs for each action. Each one starts with tasks. This is the name of the object that we're working with. Next is the action. For some, there's an ID to identify the record to find for that action. For index, you could write out index, but most often, it's just omitted. This structure works well with separate controllers, one for each of the models. You can think of each controller as a resource with actions being performed on it and the Rails convention is to use singular names for the models and plural names for the controllers because we're managing a set of tasks, not a single task. Following a common pattern for CRUD allows for clear, well-structured URLs. It keeps our project code organized. Let's add CRUD actions to our project. Earlier, we already created a controller for tasks, but let's create another one for our categories. We know how to do that with Rails generate controller and then we're going to make this categories, plural, and then I'm going to list the templates that it should create. I need an index, show, new, edit and delete template. I'm only listing the five CRUD actions that will need view templates. I will add the other three CRUD actions to the controller by hand. So here's categories controller. You can see it put placeholders in here for all of these, but I'm going to add a couple to it. In addition to new, we'll have create and in addition to edit, we will have update. And then in addition to delete, we'll have destroy. Now we have all of our CRUD actions in there. I'm going to take all of these except for index and copy them and go into task controller. Let's save this also. And let's go into task controller and let's add the same thing. I already have an index action. I'll leave it alone, but I'll just make sure that I have all the other ones there as well. Let's check our templates. If we go into the views, for categories, you see it gave us placeholder templates for all of these, index, show, new, edit and delete. That's fine. If we look at tasks, you'll see that we don't have the full set, so we need to add a couple more here. So I will just add a new file as a placeholder. I'll call the first one delete.html.erb. And let's add another new file. This one will be show.html.erb. Now I have the same five templates. Alright, let's jump over to our routes file and check out things there. We need those routes as well. You can see that it added for us routes for categories, all the ones we needed. I'm just going to move my root route up to the top, so it stays up there. I won't worry about the match routes I created before. I'll leave those there. Down here for tasks, you can see that I have a partial set. I need to also make sure that I have tasks, show and get tasks delete. 

Now we don't have routes for the actions that don't have templates. You could add those. For example, I could have one here that is post tasks create. These would use post instead of get because they will process form data. 

However, I'm not going to do that. In the next movie, we're going to discuss a different approach.

Use REST for resourceful routes in a Rails project

In this movie, we will learn about a concept called REST and see how it leads us to resourceful routes. REST is short for representational state transfer. With REST, instead of performing procedures, we're going to perform state transformations on resources. REST provides more structure by adding some HTTP verbs. HTTP verbs are the way we make requests from a browser to a web server. The most popular of those are GET and POST. GET is typically used for links and POST for forms. But in REST, it's going to be more specific about how they're used. GET is used for retrieving data about a resource. POST is used for creating new items in the resource. REST also introduces two new verbs, PATCH and DELETE. PATCH is for updating an item, and DELETE is for deleting an item. We can see how these HTTP verbs line up against the CRUD actions. You can see that index, show, new, edit, and delete all use the GET HTTP verb. They get information about the resource. It may be one item, or it may be many. It may display details about the item, or it may put the item into a web form so we can then go on to update it. The HTTP verbs POST, PATCH, and DELETE line up with create, update, and destroy. Those are the ones that make changes to the resource. GET doesn't make changes. POST, PATCH, and DELETE make changes. The combination of using CRUD actions with HTTP verbs leads us to something called resourceful routes. If the server receives a GET request for tasks, as you see in the first row, it will show a list of items. But if the server receives a POST request for tasks, as you see in the fourth row, it will create an item. The URL string is the same in both cases, but the HTTP verb indicates which action to perform. Notice also that the structure of the edit and delete URLs has changed. Instead of being controller, then action, then ID, it's now controller, ID, and then action. This is so that any action targeting an item in the resource will always start with tasks/:id and the action to perform on it is what follows at the end. You may be thinking that's a lot to keep track of and a lot of routes to put in our routes file, but Rails makes it easy for us. If we define a resource, all those resourceful routes get added to the project automatically. Once again, Rails does the heavy lifting for us. You can also use except or only to enable less than the full set of default actions. You won't always need them all. Or you can add more actions. For example, the delete action is not included by default. If you want it, you can add a code block with a member code block inside it and then a get route for delete. This is a member route because we're expecting to be working with a specific item in the resource, in this case, a single task that we want to delete. We can expect it will send in an ID in that URL so we can find the task. If an action will operate on the resource as a whole or generally and not send in an ID, then you would use collection. For example, if an action will export all of our tasks, collection would be the appropriate choice. And you can use any of the REST HTTP verbs for these routes: GET, POST, PATCH, or DELETE. So in our routes file, I'm just going to comment out all these old routes that we have in here. And I will actually move these as well. Let's just take them down to the bottom. Put them below the tasks. And let's comment these out as well. We won't be needing them. We can still leave these in; there's no harm in having these others. But let's add a new one for resources and then categories and resources :tasks. Let's also go ahead and add the delete action to each of these. We'll do that with a block do/end, and inside that block we'll put member and do/end, and then inside there the route we want, get :delete. And I'll just copy that, and let's add it to this one as well. So we have our full set of default routes plus that delete get action. Delete is optional. A lot of projects skip it and just go straight to destroying the object. Let's save it and let's try it out. Let's go launch our Rails project, and let's go to Firefox localhost:3000, and let's first just go to Tasks. So that's our index task, so it routed it perfectly fine. Remember, we commented out the old route, so this is using our resources route, Let's try tasks/new. Now this is just an empty template, a placeholder, but you can see that it routed it to the right place. And let's try tasks/1. That's going to show the task and we can see that here. It processed it by TaskController#show. And let's do another one here. We'll add edit to the end, and you'll see that it's in it correctly to the edit action. So while there's a lot conceptually to understand about how resourceful routing works, in practice Rails makes it very easy to just make a simple definition in your route file and get access to these resourceful routes.

Use resourceful URL helpers

If we use resourceful routes in our Rails projects, then all of the links and forms will need to use URLs that match those routes. Rails provides helper methods to make this process easier. You can continue to write your URLs as a hash with the controller, action, and ID. And as it did before, Rails will look in the routes file, find the resource you defined, and use it to construct the right string to use. But the same URL can be written with a Rails helper method as task_path, and the idea of the object as an argument. The code is shorter and clearer. When we defined the resource in our routes file, Rails also created a corresponding set of URL helpers like this one. The names of these helper methods follow a pattern. In the first row, you see tasks_path, which is plural. That makes sense because it will show a list of several tasks. It uses the HTTP Verb GET with it because it's getting information. Notice that tasks_path shows up again in row four. When we submit a POST request to the same URL, it adds an item to the set. Both of them use the same URL so they can reuse the same URL helper. Notice that the helper method, task_path, singular, is used three times. When it gets used with a GET request, it shows the record, with PATCH it updates the record, with DELETE it destroys the record. The remaining three URL helpers are different, but they also follow a pattern. They use task_path, but they add the special action name in front, new_task_path, edit_task_path, delete_task_path. new doesn't provide an ID because the record doesn't exist yet. Remember that we added that DELETE action in the last movie as a member route. So any custom member routes you define would work the same way. You would add them as a prefix in front of task_path. You'll be surprised how quickly you get used to these. These helpers can be used as the target in your links and forms. Here are examples for listing all tasks, showing a task, and editing a task. In the Show Task link, I'm sending in the task idea as an argument explicitly, but if you simply provide the object, as I did with Edit Task, then Rails will get its ID for you. Either way works. Let's try some of these out. We already have our resourceful routes defined. So now I'm going to add a link, and I'm going to do that inside views, main, and the index template. I have a link to all tasks here, but I don't have one for categories. So let's add link_to, and now I'm just going to go ahead and put a br tag at the end, and it's going to be a link to Categories, plural. And because it's plural, we're going to use the helper method that Rails gives us when we define the resource, Categories, plural, and path at the end. That's it, that'll give us the link. We can do the same thing for tasks, but it's going to be tasks_path, that'll take care of everything that's here, but notice that we also have this extra parameter. We can actually just pass that in as an argument. Make sure I get rid of that curly brace there. So it's tasks_path, but I'm also telling it to pass in the URL parameter page 1 along with it. Before we try this out, let's go to that tasks index page. And we've already got a list of tasks here, but at the moment, these tasks are not coming from the database. If we go and look at our controller for those, you'll see it's just a static text list. So let's don't mess with that yet. Let's just go back into task index and right here below it, let's add a new link. Then we'll just sort of mock this up. link_to, and let's put in First task, and the URL for that is going to be task_path, singular, and then the ID for it, and I'll just put in a hard coded one for now. Eventually that'll come from the database. And then let's take this same thing, but let's come over here to the show page. And on the show page, let's add a link that'll say Edit task, and it'll be task_path, but this time, we need that edit prefix in front of it, so edit_task_path 1. Let's launch Firefox and try these out. So here we are, let's go to the root of our website first. I get that Categories link. If I click it, takes me to categories. And Tasks takes me to tasks, and it keeps that URL perimeter page 1 at the end. Here's that link for First task. When I click on that, it goes to tasks/1. When I click on Edit task, it takes me to tasks/1/edit. We won't use all of these URL helpers just yet. Hopefully, though, you have a sense of how resourceful routes work inside a Ruby on Rails application. In the next chapter, we'll be using these as we build full webpages that perform CRUD actions.

CONTROLLERS AND CRUD

Read actions: Index and show

In this chapter, we'll put everything we've learned into practice. We will create webpages that can create, read, update, and delete records from the database table. We'll begin with the two read actions, index and show. Both index and show will use GET for their requests. Index will display a list of records. Show will display details about a single record. We already have our resourceful routes, and in our controller we already have placeholders for our different CRUD actions. We also already have placeholder view templates. We need to add code now to the controller and views. In our task controller for index, we have some code already from when we were experimenting. I'm going to remove page. We don't need that. But I have tasks here set right now to just a simple array. I want to get that array from the database instead. And we know how to do that with Task, dot, and then I can use all if I want everything out of the database, or I can use order to sort them by position, which is what I want in this case. Now I have an instance variable set that's available to us in the template. We don't have to specify the template because automatically it'll render the index template by default. So here you can see in the index action I've already pasted in some HTML. This is included in the exercise files, or you can pause the movie and copy it down. At the top, I still have my Back to Homepage link that I had before, that goes to a just regular route, not a resourceful route. Then I'm going to put a list of tasks. And I've got that in a table here, at the header, you can see the top, the header information. And then I've got that task each loop that's going through each task. Before I was doing that with a ul tag around it. Now I'm doing it as a table. And for each task I'm going to list its position, its name, whether or not it's completed, and its category name. A couple of notes here. Completed automatically has a question mark version because it's a Boolean, so we can use that. And this kind of operation here is called a ternary operator. And if it evaluates to true and it is completed, it'll output Yes. If it's not, then it'll use No. Here with category, this little operator tells Ruby to only try to put out the name of the category if the category exists. If the category doesn't exist, don't try. Just go ahead and output whatever's on the other side of this, which will be a dash. Now I've got placeholders for all the links, like Show, Edit, Delete, Add New Task. We're going to be filling those in. For now, just notice that we'd set the instance variable tasks here, and at index, we're able to use that to loop through each of the tasks. All right, so let's create that Show link now. We know how to do that. We have link_to, and then we just need to use that RESTful URL helper. So it will be singular task_path, because we're looking at just one task. And we need to provide the task ID or just the task object. That's it. Now this will be a link to our Show page. Let's save it, and before we go try it out, let's implement the show action as well. So in show, we need to find the task specified by that ID. The idea'll be sent in the parameters. So we'll have task singular equals Task.find, and then params id. That's it. Once again, we don't need to specify the template. It'll use the show template by default. And once again, I've pasted in some HTML. This is included in the exercise files, and it gives us a good starting point. The only link that we'll put in right now is this Back to List link, which will take us back to the index action. And we know that's going to be tasks plural, path. That'll be a GET request to tasks_path, and that will return us to the list. Let's try it out. Come over here and run rails s, launch the server. And bring up Firefox, localhost:3000. Here I am on my main page. I'll click Tasks. I get my list of tasks. I've also got a Show link here. If I click the first one, it takes me to details about Fold laundry. If I click Back to List, let's try the second one for Show. It takes me to details about Sweep porch. So you can start to see how these IDs allow you to bring up individual records and to move around within the resource. This same design pattern works with any other database-driven resources in your web application, perhaps products, customers, or users. You can create webpages to read a list of records or a single record from the database.

Create action: New

In this movie, we will implement the new action. But to do that, we first need to learn about form helpers in Ruby on Rails. At the start, I want to point out that the Rails code we put into a template is not magic. It just creates HTML on the end. That means that you can use a basic HTML form like this to create a task if you want to. When submitted, the controller action could retrieve each of the form parameters and use them to save a new task to the database. However, the Rails form helpers make this process easier and better. This is a form using the form_for helper. You can see it passes in the object task as an argument. So throughout this form, it has that object available to it to work with. The output to the template will be roughly the same but it has several advantages. One advantage is that the form parameters will all be grouped together. This makes them easier to work with inside your controller. It's also easier to remember how to construct the form inputs because they're consistent. In HTML, you have to remember several different types of tags and how to use them. Rails will also use the object to automatically pre-populate the form fields with values. In HTML, you would need to add code to assign each value to the field. And Rails knows if the objects is a new record or an existing record. So the form helper can choose the correct resource for route to use for its action and method. There're many other advantages. I won't list them all. Our new action will use such a form. It is the first half of creating a new record. It displays a form that then submits to the create action. And the create action will process the form data and create the new record. Before we work on the new action, let's go to index.html and let's add a link to it. So we have new Add New Task here with a placeholder. Let's replace that with new_task_path. That will give us a link to the new action. I'll save that. We have our new action right here. What should that new action do? Well, it should instantiate a new task. Task.new. Now this object is available to me in the template for me to use inside my form helper. I'm going to go to tasks, new. You'll see that I've included some starter HTML for the new template and this is in the exercise files. You'll see that I've already got the form_for helper being used. I'm going to output that, so I need the output tag. I'm passing in that object that I just created. And because this is an unsaved object, it'll know that the URL ought to be tasks_path and it ought to use the post method. It'll handle that for me. Then you can see that I have this block variable f available to me throughout this form creation process and so I can call f.text_field and it'll create a text_field on the form. The f represents the form. That text_field will be called name. I can also have one for position, completed. Here I have a check_box, here I have a text_area. And then at the bottom, I have a submit button. And then you've got to be sure to end the form down here because everything from do to end is one big block. That's it. Let's save it and give it a try. So let's launch our server. And then we'll go into Firefox. Let's go back to our homepage. Tasks. And then let's click on Add New Task. And you see it takes us to tasks/new. Here our form, Create Task and we're ready to enter information to it. And of course, we don't have our create action written yet so we can't really submit it but let's just take a look real quick. If we do Tools, Browser Tools, Page Source, we can come down here to where the form is and you can see that the form action, it's going to be tasks, and it's going to be method, post. It included that for us. You can also see how it named each of our attributes with task in front of it in square brackets, which allows them to be grouped together when they arrive as parameters inside our controller. All right, for now let's close that back up, and let's go into the controller again. and I just want to show you that you can also put in default values. So let's say, for example, that the position is something I want to set by default. And let's go ahead and have a count equals Task.count. That will find out how many tasks there are. And the position of a new task ought to be count plus one. Now when we come back over here, let's go back to list, oh, we didn't make that link yet. Let's fix that link. New. The very top, Back to List, this will go back to our tasks_path. There we go, let's reload our page. Back to List takes us back. Add New Task. Now you can see it pre-populated that field with the value three. We didn't have to tell it to populate that value. Rails did it automatically because it had the object to work with.

Create action: Create

In this movie, we will write the create action and learn to work with form values. In the last movie, we added code for the new action. It has a web form that will submit to the create action. The create action will process the form data and create a new record in the database. It won't need to have its own view template. The create action will instantiate a new object using the form parameters and then try to save the object. If the save succeeds, it will redirect to the index action where the new object will be included in the list. If the save fails, it will redisplay the form, populate it with the object submitted values so that the user can fix any problems and resubmit it. Why would a save fail? Rails also lets us add data validations to our models so that we could require certain attributes or other conditions before we would let this save succeed. We're not going to be doing that in this tutorial, but that's one way that it could fail. Let's go into our task controller. And in our create action, let's add the code we need. So we're first going to instantiate the new object, task equals task dot new. And we're going to prepopulate it with the parameters that are sent in by the form. It's in params, task. Then, now that we have that new object, let's try saving it. I'm going to do it with an if in front of it. If task dot save. And I'm going to put else it end. So if it succeeds, it'll do one thing. If it fails, it'll do something else. If it succeeds, let's redirect to the list. That's the index. And the helper for that is tasks underscore path. If it fails, then we want to rerender the form, and that form is the new template. So that's where we're going to render. But I want to put a note up here just to remind you that the new action is not being called here. So the code that's inside this action right here is never going to be executed. This is just rendering this view template. That's it. As a consequence, that means that we need to make sure that we assign any instance variables needed. Let make that plural. So for example, if we had needed the count instance variable in our template, then we would need to make sure that we put that in here. I'm not in fact using it on the template, but I'll just put it here as an example. It's the controller's job to make sure that template has everything it needs. And if those templates are expecting to have the values, for instance, variables, we've got to set them before we render them. Okay, let's save it, and let's try it. Let's launch our server and open Firefox. Here's my form. And let's put in the name here. Let's say wash dishes. It'll be position three, not completed. And the description will be wash and dry the dishes. Now I'm going to click Create Task. And it failed with a forbidden attributes error. Rails lets us set many object attributes at once using a hash. Examples are new, create and update. However, if these values are coming from the user's browser, our Rails applications needs to ensure that they're trustworthy. Imagine if a hacker altered a form to send an additional value. If our code simply accepted it, the hacker might update something we didn't expect. In this example, our imaginary hacker was able to change the user's password. So you can see why this is a problem. Rails protects us from this scenario using something called strong parameters. If we want to use the form parameters without getting a forbidden attributes error, then we must tell the parameters which values are allowed. Any other parameter will be ignored during mass assignment of the attributes. We also use require to make sure the expected form parameters exist. In this example, under permit, I've listed name, position and completed. I did not list description. So that form field's value would be ignored unless I added it. Let's use this to fix the error. So we'll go back in our code. And here, instead of using params, task, we're going to use params, require, task, which will return pretty much the same thing. But we also want to permit certain values. So I will use permit, followed by name, position, completed and the description. Those are the only values that'll be allowed. If a hacker tries to add something else, it'll just get ignored. Now, we'll need to do this later when we have our update action, too. It's going to have the same problem. If they share the same list of attributes, then it's helpful to take this and move it. I'm just going to cut it. And I'll come down here. And I will make a private method that I will call task params. And inside there, it will just do that same thing, right? It's nice. It's easy to see. And you can even do things like break these up onto separate lines, which I'll do quickly. So now you can see which parameters are permitted. And task params gives us a handy method that we can put in here instead. So this will have the same effect. It'll output the exact same thing. It'll run this same code. Let's save it. So we'll come back over here. We'll hit the back arrow. And let me try again, Add New Task. And the new task is going to be wash dishes. And the description will be wash and dry the dishes. Now, when I click submit, this time it worked. And it redirected us to the index page where we see our new task.

Update actions: Edit and update

- In this movie we will add the ability to update existing records. Updating has two standard actions, edit displays the form and update processes the form. The pair of actions have a lot in common with new and create and the form for creating and updating records is often the same form. The process for updating and processing the form data is also similar. The update action will query the database for a record with the requested ID, then it will use the form parameters to update the object. If the update succeeds, it will redirect to the show action where the changes should be visible. If the update fails, it will redisplay the form with the submitted values so that the user can fix any problems and resubmit it. Let's start by first going to our index template and where we have a link to the edit action let's add a link that will get us to this first page. So that's going to be the edit task path for the task. And I'm just going to copy that because I'll save it. Let's go to show. I have another link on the show page that also will take us to editing. But this time we need an instance variable for task cause we're not inside that loop. Now I have two links that'll take me to that edit page. When that link is clicked the edit action will handle the request. So let's go to the task controller. Here's our edit action. The first thing you need to do is find the task. That will look exactly like the line that we have up here in show. It will find it using prams ID. So I'll copy that and paste that down here. Now that we have an instance variable it allows the form to present the current database values for editing. To get the starting HTML for this edit page, I'm going to go to the new template and do select all copy and then come over here, select all and paste. And let's just make a couple of changes here. Instead of create task, it's going to say edit task. And the class here we'll say edit, but it'll still go back to the list. And then the URL it creates is going to be slightly different because it's going to be an existing object. The URL that it's going to come up with is going to be task path with the task, and the method will be patch instead of post. And all of this will be the same. We're going to be able to edit the same things but the button will say edit task instead of create task. Let's try it. Let's launch our server. We'll go into Firefox. Here we are on our task. Let's reload that page and fold laundry. If I click edit, you see I get my edit task page task one edit and it has the existing database values pre-populating those fields for me. If we choose tools, view page source, we can actually look at the form that's there and you can see here's the action. Task one is where it's going to submit to. But notice that it says it's a post. I just told you it was going to be a patch. What's going on there? Well, rails actually cheats a little. There is this other field here that's an input field that's hidden whose method value is patch. So it uses a post method which is widely supported by all web browsers, and instead it adds this hidden field so that it treats it like a patch when it arrives. It makes it restful. All right, let's close that. And now let's add our code to actually process these values when they're received by our controller. So the update action right here, the first thing it's going to do is also find that same object by its ID. Then the next thing it's going to do is update that object. Task dot update. And we talked about mass assignment and strong parameters. So we want to use task params for the params instead of just using the params on its own. So we want to make sure we permit those values update will return true or false. So let's check to see if it does succeed. We'll do one thing. If not, we'll do something else. If it succeeds, we could redirect anywhere but I'm going to redirect it to the task path for this task. So that's the show page. And then if it fails, we will render the same edit template again, just like we did up here, rendering new we're going to render edit and the same caveats apply. It's not actually calling this edit action here. So we want to set up any instance variables that it might need. Let's save it and go back and try it out. Fold laundry position one, fold the laundry in let's just expand this a little bit fold laundry basket and put it in the drawers. We'll just make a simple change like that. Now click edit task. There it is. Put it in the drawers. We're now able to create webpages to update records in the database.

Use partials to organize code

In this movie, I want to introduce you to something called partials. Partials are important for good code organization in your Ruby on Rails project. They help you to not repeat yourself. A partial is a partial template. It's meant to be shared between other templates. You may have noticed that our new and edit forms have a lot of code in common, especially the list of form inputs. Instead of repeating that list, let's create a partial that can share both. Then if we make a change, the change will appear on both forms consistently. I'm going to create a new file in my task directory, and I'm going to call it _form.html.erb. The underscore at the start of the name is the Rails convention to indicate that this is a partial template, not a full template. Let's move the code that we want to share into this file. I'm going to take everything in the new template that is part of this table. That's all of those inputs. I'm going to leave form for and the buttons separate, just the part of the form that's in the middle. And I'm going to cut that. I'll go to form and I'll paste it in. I'll save it. Now we need to tell the new template to load in that partial. We'll do that with some ERB tags, and we'll use the render method inside. This is just like the render that we were doing in the controller, but now we're using it in the view in order to render this partial. So the next thing is we'll put in partial and give the name of the partial. That's going to be form. And notice that I did not include the underscore. Rails knows this is a partial because we referred to it that way. So it will add the underscore when needed. Now, the form that we've added has this local variable F that it was working with. The partial will not automatically have access to that local variable. We need to pass in that value as a local variable when we call render. So render the partial form, and the locals that should be presented to it are, and I'm going to call it F:F. What that's saying is, take the value of F that's here and pass it in as the local variable to the partial called F. I just happened to have called them the same name. Let's save it. We go over to form. You can see then F is being used here to render each of these text fields. Now I can take that same line. I'll go to edit and let's take the table and replace it. Now, both of them are referring to the same partial. I'll save the change. Let's launch our web server. We'll go into Firefox. And if I go to add new task, I get the form. If I go to edit a task, you see I still get the form as well. And if I were to make changes of this form, the changes would apply to both of them. Partials play an important part in keeping your code well organized.

Delete actions: Delete and destroy

In this movie we will add code to delete records in the database. Delete is also made up of two different actions, delete and destroy. Delete will display a page to confirm the deletion and destroy will perform the destruction of the record. We already saw that delete is not a default resourceful route. We had to add it. It is the action that's most often omitted out of the set. A link to destroy, may just immediately delete the record or that link may have some JavaScript on it that displays an alert and asks the user for confirmation before it goes forward. Our approach is to present a new webpage for confirmation. It's a question of style and personal preference. Let's start by adding links to our delete page and I'm going to do that from my task index page down here. I'm going to just copy this one that I had for edit because we're going to have the same thing for delete except that the special action at the front will be delete. Delete task path with task. And we can copy that because we also have it on the show page as well. I have the ability to delete from this page but I need to have the instance variable task 'cause I'm not inside the loop anymore. All right, so those will give me links to the delete page. I've included some starter HTML for the delete template in the exercise files. It has a form for doing the deletion. Notice that it has method delete declared in the form. When we were doing create an update, we just did form for task, right? But this is a saved record. So if we just had form four task, Rails would see this as being an update statement. So we have to tell it that no, we want this to be a delete. So we have to specify it when we're working with delete. It'll come back and say, are you sure you want to permanently delete this task? It'll show the task name and give us a submit button. Let's save that. And once that is submitted and we click the submit, it'll come to the task controller and we need to put in something for our delete action and our destroy action. First thing the delete will need to do is just find the record. That's it. Just find the record and display it for the confirmation form and we're going to do the same thing in destroy. The first step is going to be define the record. After that we can just call task.destroy. Remember we want to use destroy and not delete. And then after we do that, we can simply call redirect_to and let's redirect to the tasks path, 'cause we can't go to the show page. The record's gone. So we'll go back to the main list page. Now we could add an if statement inside this method like we did with create an update. Those allowed us to prevent saving if they're sent bad data. But destroying records doesn't have the same data issue and we usually can just destroy and redirect. So there's really not a reason to have it. Let's try it. Let's save this. Make sure everything's saved and let's come over here and launch the server. I'll open up Firefox. Let's go back to the list. Now let's create a new task that we can delete and I'm just going to call this one, delete me. I won't fill out anything else. Create task. Here it is. Item number four and I'm going to click on delete. Are you sure you want to delete this task? Delete me, click delete task. It redirects us back to the index page and we can see that the task is now gone. Notice on this index page there are four links that represent parts of the crud. We've learned how to create, read, update, and delete the records in our project database.
