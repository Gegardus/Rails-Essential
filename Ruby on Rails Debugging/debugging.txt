BACKTRACES

Unlocking full backtraces

Rails usually displays fairly descriptive errors and it's easy to see what's wrong. In this case, the error message indicates that an uninitialized constant was called. Next, you can see the code that throws the error. Below there's the backtrace, where you can see the exact location of the error, comprised of the file path and the line number. An interesting part here is the backtrace filtering. There are three links above the backtrace. The first one is the application trace. This filters out all the steps followed by the framework until getting to the point where the error occurred. The second one is the framework trace which only contains the framework steps. It's pretty large, starting when the server started processing the request. The third one is the full trace. It combines the application and the framework traces. There are times when you'll see weird errors that won't be familiar to your code. It's like the code you've written has caused a malfunction somewhere in the application and Rails will be showing you a hint because it's complicated for a framework to interpret what might have happened in cases like this. In these cases, you may think you've encountered a bug in the framework or in some gems you are using in your application. Although there's such a possibility, it's extremely low. The problem almost always will be in your application. So if in cases like this you can't find any clue in the application trace, I recommend you switch to the full trace to investigate and follow every single step in both the framework and your application. If you are in the console, you'll notice that by default, Rails displays the application trace when an error occurs. To display the full trace you must remove the silencers. To do this, create a file in /config/initializers' called 'backtrace_silencers.rb. Use the Rails 'backtrace_cleaner' object, and call the 'remove_silencers!' method. Now restart the Rails server. Reload the page. Now you can check the full trace in the console too. In short, with practice you'll find errors faster by interpreting exceptions better. The error message will be enough to know what happened in most cases. But if it's not clear, you'll have to read the backtrace. Start at the top and work your way down when reading the backtrace because the error will usually be found in the first few lines. Always look for paths starting with app because the error will usually be in your application.

When an error occurs while developing, you can see a full trace in the error screen, clicking on Full Trace. Or in the console, after removing the silencers from the backtrace_cleaner. Remember that you will not see a full trace in the console while developing by default.

Solution: Backtraces

The first backtrace is about a no method error. Rails shows that the permt method doesn't exist. The problem originates in the posts_controller file on line 24 inside the create method. You can then deduce that a post is being created. Then, on line 68, inside the post_params method, the parameters that have been received from the form are processed. Looking at the line of code that failed, you can see that you are retrieving the post from the parameters and that what you really want to do is to allow the title and body attributes. In cases like this, Rails suggests the correct method name, which is permit. The second backtrace is about an error in a template. The first thing we see is that the title method of a null object is being called. The code comes from the partial post in line five. In that line is where the title method is being called. Probably the object has not been initialized, so the controller should be checked. 

The third backtrace is different because it doesn't come from the use of the application but after running a database migration. The error says that there's a foreign key that cannot be null. The key is user_ID. Below is the migration file. And by the name, you can see that this key is being added to an existing posts table. The problem is that the posts table exists and has records. This create a conflict when adding a foreign key that cannot contain null values. The solution would be to modify the migration and allow null values, then running it again. Next, you'd have to add the values and create another migration that adds not null to the attribute.

DEBUGGING IN TEMPLATES

Debugging variables

Perhaps the most basic form of debugging in Ruby is to use puts to display the contents of a variable at a given time. Let's assume that you have this method in the Post model to change its state to draft. Your application calls this method at some point, but the state of the post is nil. (notification beeping) That's weird. You decide to place a puts to see what's inside STATUS and you see this hash. Whoa, it looks like the keys are symbols, not strings. So now that you know what happened, you can fix the method by setting the key in the correct format. (notification beeping) So puts is the tool you should always try first when you're sure where the bug is, but you are not quite sure of the contents of a variable.

Debugging functions

Many times, the code goes through the execution of several consecutive functions. In this code, there are three functions. If you want to know precisely in which order the functions are executed, you could put a PUT inside each one. And when you run it, you'd see this output. This way, you can see that method one is executed first, then method three is called, and finally, method two is called. 

There's another alternative way to do more or less the same thing. And that's by using Ruby's Caller function. To see an example, let's remove the PUTs, and let's set the line numbers. Now, add the Caller function in the last method of the call chain, passing the parameter zero to indicate that you want to start at the beginning without skipping any steps. And this is the output. It starts at the most recent execution and ends with the first one. The last step is line six, where we are calling caller. The previous one is on line 10, calling method two. Here is line two, where we call method three. And the first one is on line 13, where the execution flow starts, calling method one. Both PUT and Caller are elementary and valuable tools to verify a complicated execution flow. And I recommend them as a first step when you are not sure about the order of the function calls.

Remember that the output goes from the most recent call to the oldest call. That is, in descending order.

Debugging objects

Puts is a simple but helpful tool for seeing what variables and functions contain. But it may not be enough for objects such as models. In this case, we can use other tools that give more information. Inspect, to transform the value of an object to a string. to_yaml, to convert the value to YAML format. Debug, which will be the final tool to see the content of an object with the best format. Let's see it in a practical example. Open the terminal and create a user model with the generator. Add in the fields, name and email. Now, create and migrate the database. Create a new user. With email john@example.com. And name John. Create a controller called home with an index action. Now, open the routes file. And set the index action as the route of the application. Open the controller. And in index, create an instance of user. Open the template. Delete the content and add the title, plain object. And simply display the object on the screen. In the terminal, start the server and open the application in the browser. You can see that Rails displays the object's ID, which is not particularly useful if you need to know what values it contains. Back to the template. Let's see what other ways we can check the contents of the object. The first way will be with the inspect method. Simply call inspect on the object. The second way is with the to_yaml method. It starts with a simple_format helper, so, it doesn't show everything in one line. And call to_yaml on the object. And the third one is with the debug helper. Simply call it and pass the object. It's a shortcut that does the same as to_yaml. Let's check it out in the browser. With inspect, you have the object values in a single line in string format. This can really give you a quick glance. If you need more information, use to_yaml. It tells you where it's attribute comes from. As well as its value before doing the conversion to string. And with the debug helper, you get exactly the same result as with to_yaml, but with simpler code. It's also displayed with a monospace font, which is more suitable for source code. I've shown you how to use to_yaml, so you can see that it's equivalent to the debug helper. So at the end, you have two tools. Inspect, if you need something quick and debug if you want more information.

BINARY SEARCHING

Binary searching your code

It's pretty common to encounter a variable or function that is not returning the expected value at some point in the application. Often the solution is not apparent. One of the simplest and most effective techniques is binary searching. It consists of splitting the portion of the application code, where you're looking for the bug. Hence the name binary. Suppose we have an application with this code and something is not working as intended. Let's think that a variable is returning nil when it should not. There are quite a few lines and several function calls. It would take quite some time to go through everything thoroughly looking for the bug. Using the binary searching technique, let's split the code. Add a puts in between and see what the variable returns. If the puts doesn't return the expected value, for example, nil, it means that the bug is in the first part and you can discard the second part. If it returns the expected value, the first part is okay, and can be discarded. So you should continue searching in the second part. Let's assume this case. Now add a puts right in the middle to split the code again. Let's assume that it returns the expected value. So you can discard the first part. Next add the puts in the middle to split the code and repeat the previous steps. So on and so forth, until you isolate the bug and quickly identify it. Another way to use this technique is when you have unexpected behavior in the application. You could remove or comment code. This way you discard halves until the unexpected behavior disappears. And you'll have to look in the last removed chunk. This technique has rarely failed me in my more complicated debugging sessions since it allows me to isolate the problem to the maximum. I think it's one of the best resources you can have.

When applying the binary searching technique, if the value you are looking at does not return what you expect, means that the bug is in the first part, i.e. there is something in the code of the previous part that is affecting that result.

Manual binary searching in tests

If a test in your application fails randomly the binary searching technique is a good way to isolate the problem. Usually the problem occurs because a previous test has changed some data that has affected the next one. The moment you detect the failed test write down the seed. This way you'll be able to reproduce the error. The first thing to identify is what type of test is failing: a model test, integration test, system test, and so on. Suppose it's an integration test. The manual way to isolate the problem will be to remove half of the integration tests and re-run the integration test to it. One way to temporarily remove those tests is to move them to another location. So move them there to retrieve them easily later on. We run the test to it. If the bug no longer appears it was in one of the deleted files move the files back and delete the other half. We run the suite and the bug should appear. Repeat the operation, always keeping half of the suite until you identify the file or group of files responsible for the failure. Then apply the same technique, but to the content. Open the file and delete half of the test. If the problem still occurs, delete another half, and so on until you have isolated the problem to identify it and fix it. Binary searching is a technique that adapts to different situations. As you have seen it's also very effective for the testing environment.

Automatic binary searching in tests

Test suites are usually quite extensive covering most of the application code. Therefore, doing binary searching manually can be pretty laborious. Fortunately, for both Minitest and Rspec, there are automatic ways to do it. For Minitest, there's a gem called minitest-bisect. For our spec use the --bisect option. Let's use Minitest as an example. We need something that has a global state. Let's create a model called user. Create and migrate the database. Now define an attribute accessor class: has_permission. Generate an integration test. Open the file and un-comment the example test. Rename it to A1. Duplicate this test four more times. Let's rename them. Now we have five tests that do one assert each. If you run integration test suite, you'll see that everything is correct. Duplicate this file with another name. Adapt the name of the class and the name of the tests. Create another one. Ctest. And why not, create another one. Dtest. Now the suite has enough tests. We run the suite, everything in order. Imagine that one of the tests in a_test, needs to modify the global variable to false, but forgets to leave it true. This would cause all the tests to fail, but let's assume that this is random to cause a situation where it doesn't always fail. Let's assume that a test checks that the class variable is nil in one of the other test files. Run the suite. The if hasn't been executed. Keep trying. Now it has failed. To always replicate the situation, copy the seed value. You can replicate it this way. Now, install the gem. Open the Gemfile, and add it to the test group. Install it. And now run the gem. Pass it the seed, and the directory with integration tests. The gem performs a binary searching until it finds a minimum number of methods responsible for the failed test. Until identifying a list of methods, as you can see in this array. In our case, it has correctly identified the test that modified a global variable. The following shows the output of the failing test. As you can see, in a matter of seconds, this automated way of doing binary searching can help you a lot with those tests that fail randomly. Just remember the seed to be able to reproduce it.

RSpec supports  binary searching technique via the --bisect option, unlike Minitest, it is built-in.

Binary searching in Git

There are several ways to debug with Git. If you already know where the bug is, you can do a git blame of the file in question, and git will show you each line, along with the hash of the commit and its author. But if you don't know where the bug is, you can do a git bisect, which runs a binary search algorithm. Let's see how it works. Let's see an example with multiple commits. First, create a user model with a fields: email, name, and last name. Create and migrate the database, and open the model. Let's create a method called full name, that will concatenate the first name and the last name with a space in the middle. Go back to the terminal and go into the rails console. Here, create a new user with the email, "someone@example.com". First name John, and last name Doe. This way if you call full name for the first user you'll have the first and last name separated by a space. Exit the console, and add all the changes to Git. And make the first commit. Now go back to the model to make a change. Let's just add comments. Add the change and make the commit. Add another comment. And this time let's introduce a bug by removing the space between the first and last name. Add the change and commit. Add the third comment, git add, and commit. Add the fourth comment, git add, and commit. Add the fifth comment, git add, and commit. And finally add the sixth comment, git add and the commit. At this point, let's call the full name method. As you can see, there's a bug. There should be a space and there isn't. If you do a git log, you'll see that there are quite a few commits. Knowing that that space existed initially, how do you know which commit removed it? One option is with git blame, but let's see use Git's built-in binary searching, which will tell you exactly which commit introduced the bug. To start the search type git bisect start. Now you have to tell which commit has the bug. With git bisect bad without parameters, Git understands that it's the current one. Next you have to specify which commit didn't contain the bug. Look in the log for the first commit and copy the hash. Pass it with git bisect good. As you can see git checked out the commit from the middle of the log. You can see this more clearly with git bisect visualize. It's just a git log, but the HEAD is set to the middle. Now check if the bug is still present by repeating the rails runner command. Yes, the bug is still there. So let's specify that this commit is bad. Git cuts it in half, backward again. With visualize you can see it more clearly. Git has removed half of the commits and put the HEAD in the middle of the other half. Repeat the rails runner. It's still present. Specify again that this commit is bad and repeat the rails runner command. Now the bug is gone. So tell Git that this commit is good. Now Git tells you which commit introduced the bug. To exit this mode type git bisect reset. In a real situation you'll have many more commits to investigate, but you'll save much time with this technique.

Automatic binary searching in Git

Git offers an even faster way to find the commit with the bug, by automating the process with a script. This script should return one, if there's an error and therefore Git should continue searching or zero if there's no longer an error. So that Git stops and considers the current commit as good. Let's create in the root a script called bisect check. Start by writing the shebang comment. It'll contain an if and inside, it compares the command rails runner with expected value, with a space in the middle. If it's true, the script exits with code zero. If not, it exits with code one. Now in the terminal give it execution permission and move it outside so that Git doesn't detect it. Let's look for the first comment hash. Here it is. Start the process with git bisect start, first pass the current comment. And then the first one you know didn't have the bug. Now call GI by SEC, run and pass the script. Now Git is doing the splits automatically depending on the script's return in each step. And it returns the commit where the back was introduced. Git is a tool that can work very efficiently to help you find when, and how a bug was introduced in the code. From there, you can continue investigating with other resources that Ruby on Rails includes.

LOGGING

Using logs

A new Ruby on Rails application has development, test, and production environments. For each one, it creates a file inside the log directory. Usually the contents are queries, the files that generated them, the controller responding to each request, the templates being rendered, and so on. In development, you'll not have to look into the log file since the console where you start the server already shows its contents in real-time but you can also add any information you want using the logger method of the Rails class which you can use from anywhere in your application from controllers, models, mailers, templates. There are several log levels from the least important to the most, debug, info, warn, error, fatal, and unknown. By default, the production environment is set to the info level. You can see it in the production.rb file in the config/environments directory. This means that messages written for the debug level won't be saved but those for the info level or higher will. The reason is that the default level is generally used for the debugging and should not affect the production logs unless you change this value. There's no level configure for all other environments which is equivalent to debug. This means that all of them are saved. You can also add a prefix as a tag to better organize the messages. Using the tagged method, you can enclose a message this way and it'll print it in the log like this. This way you can take advantage of the logs that Rails already generates and complete them with information that you can use for debugging, saving time without having to use puts.

Logging: Practical case in a test

This video will show you a practical case of logging in a test. In this application, I have created a new user scaffold. Rails generates a series of controller tests that you can see in this file. If you run the test suite, you'll see that they all pass, but unlike the development environment, you don't see the log in the console. To see it, you have to open the test.log file manually. I'm going to use the ANSI colors extension to format the colors. And here's the output. Rails adds a header before the output of its test, so that it's better organized. Let's focus on one test. For example, the users list. This test, it starts on line eight. In the terminal, I run the index test. As you can see, the output of this test has been added to the log. The first query is getting a user from the fixture that appears in the setup method; but the second query, which is the one that gets all the users, at what point is it obtained? In the log, you can see that the controller is processed first, and then it renders the template. So it must be there. Let's open the template. And it's probably being done by calling the each method. To be sure, it'd be interesting to add information to the log. Let's try it. Before the each, add a message that shows the template tag to know that it's being displayed from there, and say that it's before the loop. Inside the loop, write another message. Rerun the test, and indeed the query is being executed in the first iteration of the loop. When you have problems with a test or want to have more information about what's happening, logging is a good tool that Rails already integrates by default in this environment.

Logging: Practical case fixing N+1

In this video, you'll see how to identify a typical n+1 query problem Suppose the server is having performance problems when displaying this list of posts. Let's take a look at the log. 

The first query fetches all the posts. The second one fetches a specific user. The third one is the same, but it's retrieved from the cache. The fourth one gets a different user, and the fifth one is the same, also from the cache. Notice in our point into a template and a line number below each query. It's a reference to the exact point that is generated in that query. In this case, they all point to line nine. Let's see what's there. This is a post partial. This line is getting the user from the post to display the name. Rails therefore has to do an extra query to get the user each time it processes a post in the list. 

This problem is called an n+1 query because it always makes an extra query. There may be cases where it does even more queries, being even less efficient. Now that you've identified the problem, the solution is simple. Open the post controller, and here include the user relationship. So Rails preloads it. Reload the page, and the list still works. If you look at the log, now there are only two queries. 

The first one gets the posts, and the second one gets all the users at once. Login can help you understand when and how queries are executed more clearly. This way you can solve common problems like this.

INTERACTIVE DEBUGGING

Introduction to the debug gem

Sometimes using puts in various parts of the code or sending messages to the logs won't to help you find specific bugs. In those situations you'll have to resort to a debugger. 

The debug gem allows you to start an interactive session to run the code line by line and understand what it's doing. It allows you to do interesting things like viewing the contents of variables, and calling functions with other parameters to simulate situations other than what was intended when the original code was written. 

It's a standard library included since Ruby 3.1 and you can use it on the command line and in editors like Visual Studio Code. From Ruby on Rails 7 onwards, it's included in the Gemfile inside the group shared by the development and test environments. 

To start the debugging session, you must place "binding.break" or the "debugger" alias at the point where you want to stop the execution. 

Let's see an example of stopping the execution in the controller. In posts_controller add debugger below the posts initialization. Start the server. And load the page in the browser. 

This is the output of the debugger. You can see the code snippet where the execution has been stopped, and an arrow pointing to the line just executed, which is the debugger call. Below you can see the last two entries of the backtrace. The last thing that has been executed is the posts controller, which has been called by action-pack, particularly basic_implicit_render, where you see that the send_action method has called index as a parameter. 

At this point, the posts variable is initialized. And you can see what happens when you look at its value. At first, the database queries are executed, and Rails reports that they have been produced from line seven, which is the debugger. 

It then shows the output of the variable. You can see a list of all the commands you can use by entering a question mark "?". 

The commands list is grouped by category. As you can see, it's a complete tool. With the "c" command you can continue, and the application finishes processing the page normally showing the rest of the log until the response is complete. This is the basic use of the debug gem but it has many interesting things that we'll cover in the following videos.

You can monitor the total number of posts while debugging your application by adding the expression @posts&.count to the watch section list.

Navigating the execution flow

[Screenshot at 2023-04-24 14-29-42] In this video, I'll show you how to interact with the debugger. Considering the current context. Once you enter the debugging session, any code interpretable by Ruby, will have the Ruby comment following it. For example, when doing a query with Active Record. You may jump from one class to another, as you move through the session. You can use the "self" command to know where you are. 

The context is currently the post controller. Finish the session. I'll add a method in the Post model that returns the titles with the author's name. Create a class method, that goes through all the posts and returns the title and the author's name. Now call it from the controller. Reload the page and go back to the terminal. Where the debugging session is already started. I'm going to clean up the terminal. The essential thing is to know where you are, at any given moment. For that, I recommend you two commands. The first one is "L" for list, which brings up the code snippet and shows the arrow marking where you are. Be careful because if you do it again, it'll continue to list the next lines. 

As you can see. The second command is "F" for frame. Which is more specific. It tells you what class and method you are in as well as the file and line number. With this, you can pass the line number to the list command and see the snippet again after the current point. You can use Ruby's "self" method, to see the current class. 

The info command "I", summarizes the variables you have access to, at the current point. If you want to expand that information, the outline command O, lists all the methods and variables you have access to. 

To go to the next line, you can use "N", which is a step over. Now I'm at line eight. Calling the custom method I created before. At this point, you can step into the execution of this method. 

For this, enter "S" which is a step in. In the snippet you can see that you've entered the method of the post model. Enter "F" again, to see that you are indeed in another file. 

So with self, you can confirm that during the post model. And if you call a method relatively, like all, post will receive it. With a backtrace command "BT", you can query the complete backtrace from the time the server receives the request to the current point in your application. Most of the time, you probably don't need that much information to see for example, the last three steps. Here you can see the call from post controller. 

Enter "N" to step over and execute the map. The queries are being made. And you are now at the end of the method. 

With the finish command "fin", you can return to the point that called this method. 

Now with "c", you can resume the execution. This way, you can discover the actual flow of the application. Maybe there's a step you didn't foresee and it's the source of the error.

Adding breakpoints

As you've seen, putting debugger at any point in the application, will stop the execution and start a debugging session in the console. This would be the simplest way to add a break point. Although, the debugger also has several methods to add traditional breakpoints. Let's take the posts controller as an example. 

Call the debugger at the beginning of the index method. Start the server. And load the posts index URL. 

To see a list of breakpoints, enter "B" for break. There are none at the moment. Create one by specifying a line number, for example, eight, so that it stops after initializing the posts variable. The debugger responds with dash zero, which means it's the first break point. Look at the posts value, and it doesn't exist yet. 

Enter C to continue, and it says stop by #0 in the break point description. So you can identify it in case you have created several. The arrow is pointing to line eight. If you look at the value of posts again, it does exist. You can also add a breakpoint in another file, for example, in user controller, line seven. 

Enter C to continue, and in the browser, load the list of users. In the console, the execution has stopped at the second breakpoint, which in this case, is number #1. If you look at the users value, it's initialized. 

Enter "del" for delete, and the break point number to delete a break point. Delete the latter, or you can also delete them all with "del" without parameters. 

Now there are no breakpoints defined. Another interesting way to add a breakpoint is to the call of a method. Let's add one to the query that does the index method. User all. Enter C to continue. Reload the page again, and you see that it has stopped because it has detected that call. But the code that appears is not from the application, but an Active Record file. internal of Ruby on Rails. This is usual when using breakpoints, but probably, you want to place the pointer in a line of your application to test things. 

Look at the backtrace. The last two entries are shown by default. Although, you can see more with a "BT" command. Each line of the back trace is known as a frame, and you can switch between them. 

Position one is from the application, so we'll have to move the pointer from zero to one. You can specify a regular expression when you print the backtrace. For example, I look for the ones in my test_apps directory. And here it is, too. 

Let me print the first three so they look consecutive. If you enter F for frame, you can confirm that you are at position zero. With a Ruby "self" method, you can see that the current context is the model. 

If you're interested in going to one, you have to go up. So enter "up". 

With self, you can see that now, the context is the controller. If you want to go back to the model context, go down with "down". 

So in this case, you can switch frames in this way, depending on where you want to test things, whether in the model or the controller. Breakpoints are a valuable and powerful tool that will help you know the execution's context at a given point.

Integrating with Visual Studio Code

Debugging in Ruby is usually done on the command line. Those who prefer to do it in a graphical environment often turn to RubyMine as a complete solution for development. But that doesn't mean that it can't be done in other editors. This video will show you how to use an extension in Visual Studio Code to use the debugging features built into the editor. It's not as powerful as RubyMine but it should be enough for essential use. Open the Run and Debug section and click on the create a launch.json.file link. By default, there's no option for Ruby. Click on Install extension. This is the list of debuggers of Visual Studio Code, add Ruby in the search field. Install the extension with RDBG in the name, Ruby Debug abbreviated. The one by Koichi Sasada. Open the Run and Debug section again, and click the Create link. Select the Ruby option. The editor will create and open the launch.json file, which is used to start a debugging session. If you already had this file created, simply click on the green Add Configuration button, and choose the option Ruby: launch current file with RDBG. Delete this block. Adapt the configuration options. Change the name to Debug Rails server. In script, replace file with workspacefolder. And after the curly bracket, add the command to start the rails server. You can delete the other parameters. Save and close the file. The file is created inside the vscode directory. Now you've configured the Visual Studio Code debugger. To start it, open the Run and Debug section and click on this green play icon. As you can see, some floating controls appear to move around the debugging session, and the bottom bar of the editor has changed into red. The icon on the right also shows a one, indicating that a debugging session is active. At this point it's important that below, in the breakpoint section, you disable the rescue RuntimeError option. This will avoid timeout problems on the Puma server. Now, you can open the file where you want to put a break point. Open, for example, users controller. Another couple of break points in the index method. You can do it by clicking the red dots that appear here. Although it's in the line where the users variable is initialized, the first one won't have executed the line yet. So that variable won't exist. As it is at the end, the second one will have the variable initialized. Open the URL of the users list in the browser. The editor opens automatically and marks the line where it has stopped. As you can see, there's a double mark in the gutter where you clicked the red button and also the line highlight. You can see what variables are defined and you have a debugging console where you can interact with the code. For example, if you look at the value of the user's variable it doesn't exist yet. One way to see a variable value without looking it up by hand is in the watch section. Click on the plus icon and type in what you want to watch. Advance to the next breakpoint by clicking the continue button. In local variables, the user's variable already appears. The expression in the WATCH section has also been updated with the total number of users. You can delete it this way. In the debug console, you can clearly see the variable value. In fact, if you click on it, you'll see the same information as in local variables. The breakpoints can be disabled this way without needing to delete them. You can disable them all with this icon. And with this last one, they are all deleted. If you want to restart the session at any time you must click this icon, and to quit the session, click here.

Using the web-console gem

Ruby on Rails uses the web-console gem in the development environment to display a debugging console on network pages. Once the console is displayed, you can interact with your application's code by defining classes, creating models, inspecting variables, and so on. The Ruby code runs remotely on the server. So it's not recommended to use the web-console in production. You can make this console appear on any page by adding the console call in the controller or template. The main difference is that the code is not stopped. So the controller action will load completely. This means that you can only make one call in the same request. Open the file where you want to show the console, such as the users controller, and add the console call. I'm going to add it before initializing the users variable. If you load the URL of that action, you'll see the debugging console below. Here you can interact with the code. If you type instance_variables, you can see that users appears in the list, and you can access it. This is because the action has loaded completely. The code execution is not stopped. Looking at the console log, you can see that the page has loaded entirely with completed 200 ok. And below, there are calls to the web-console gem. You can also use it in the template. Remove the callback from the controller, and now open the template and add the callback here. If you reload the page, the effect is the same. Let's see what happens if you call console twice. Add another call here and reload the page. The DoubleRenderError appears. Paradoxically, you have the console loaded below, but this is what always appears in the error pages. The web-console doesn't only apply to error pages. By simply calling the console method, you can use it on the page you need to interact with the code in real time.

web-console does not stop execution. It only displays a console in the browser with the fully loaded page.

FIXING COMMON ERRORS AND RESEARCHING

Fixing the most common errors when using Ruby on Rails

In a backend framework like Ruby on Rails you can face all kind of errors but a few tend to be very common. Perhaps the most common is NoMethodError. It usually happens when you call a method you have not implemented yet, which is quite common when you do test driven development. Another widespread case is that you have mistyped the method. It could also be that the method does not belong to that object or it's possible that you need to require some library. For example, I have an array and want to get the odd numbers with extract method but I have mistyped it and got this error. Notice how Rails suggests the correct method name. There's a variant of NoMethodError that by itself is very common. It occurs when you call the method of an object that you think is defined but it doesn't exist. The key to this error is to determine why that object is not defined. It could be that you simply forgot, or it might be a bug that is much more complicated to resolve. In this example, I'm calling the featured method of an object. And when I run the code Rails it says that the object is nil you have to investigate why latest _posts isn't defined. Stack level too deep occurs when a recursive function is executed indefinitely. This function can be things like a virtual attribute in a model or a partial in a template. For example, suppose you define a virtual attribute in a template and it attempts to update the actual attribute. What it will be doing is calling itself indefinitely causing the stack level too deep error. Another often happens when Rails doesn't find a record in the database. In this case, the solution is given by the error itself. For example when it cannot find the record using its identifier. Let's finish with another of the useful ones although it's not an exception error. After submitting a form, Rails displays this message in the log when one of the parameters is not allowed in the controller. Basically it shows which parameter was received and is not allowed. Then it displays the context and all the parameters. Again, the solution is given by the error itself. In this case, either that parameter is allowed or removed from the form. I hope that if you didn't know the solution to any of these errors, now you can fix them faster.

PUTTING ALL TOGETHER

Next steps

You already know several Ruby on Rails debugging tools and techniques that will allow you to effectively locate bugs in your application. However, if you want to continue learning I advise you to go deeper into the points that you've found most helpful. For example, if you'd like to know more about breakpoints, I recommend you to open the Ruby on Rails debugging guide and access the breakpoints section. You'll find other ways to add them automatically such as after executing an expression. For example, when doing a save Active Record. You can learn about other aspects such as the catch command, to start the session when an exception occurs. The watch command to keep track of the value of our variable, the options, where you can specify conditions that can be used to design a workflow. There are other gems recommended by the Ruby on Rails guide, which are very interesting. Query trace creates a backtrace for each executed query. It's helpful if a query isn't working as expected or even if you want to optimize them. If you are interested in optimizing them, I recommend Bullet. It'll inform you about queries that can be improved. Exception Notification can be handy for production environments. As you can configure it to send you a notification when an exception occurs. It's very flexible with several notification channels. You can also explore other gems to change the way data is presented which may switch your way of development better. Better Errors is a classic. It replaces the default error page of the development environment. "RailsPanel" is a Chrome extension to display the development log inside the browser in a tab inside the developer tools. And Pry is a replacement for the Ruby console in the terminal, which incorporates many debugging features. If you want Rails to use it when you open the console, you'll need to add pry-rails to your Gemfile. That's it. Thanks for watching this course. I hope you found it helpful.